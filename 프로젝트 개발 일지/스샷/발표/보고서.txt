[1]Community>QA페이지

이미지:1.png, 2.png

사용한 외부 라이브러리:
import { Link , useLocation } from 'react-router-dom';
import Pagination from "react-js-pagination";
import axios from "axios"

pagination 설정 값: 한 화면 10개의 게시물, 최대 5페이지 범위, 최근 게시물 순

게시판 페이지로써 고객들이 자유롭게 질문을 할 수 있는 페이지 입니다.
초기 게시판 진입시 useEffect로 axios post로 DB에 저장되어 있는 질문 게시물을 SELECT 한 뒤 총 게시물의 수를 반환 받고, 한 화면에 보여줄 페이지 범위를 설정하면 Pagination 라이브러리가 계산하여 총 페이지가 결정 됩니다.
그리고 userState에 게시물 list를 set하고 map으로 화면상에 나열하여 보여줍니다.

이후 내가 페이지 번호를 누르면 그때마다 useEffect axios post가 작동되어 DB에서 선택된 페이지 만큼 게시물을 생략하고 SELECT 하여 반환하게 됩니다. 동시에 sessionStorage에 내가 선택한 페이지가 기억되어 글 작성을 하거나 게시물 상세 페이지에서 '목록으로 돌아가기', '글 작성 취소', '뒤로가기'를 했을때 머물고 있던 페이지를 보여주게 됩니다.

또한 로그인을 하였을때 글작성 버튼이 보여지게 됩니다.



[2]Community>QA>Write페이지, ModifyQa페이지


사용한 외부 라이브러리:
import { CKEditor } from '@ckeditor/ckeditor5-react';
import ClassicEditor from '@ckeditor/ckeditor5-build-classic';
import axios from "axios"

글 작성 페이지입니다. 글 작성시 제목, 문의 종류, 작성 내용, 세션에 저장된 id값이 검사 후 null이 아니라면 axios post 데이터로 전송되어지고 null이라면 안내창 알림 후 return false되고 그 값에 focus됩니다. 
Controller에 전송되었을 때 또한 null값이 아닌지 검사후 DB에 저장 되고 그 결과에 따라 다른 response값을 반환합니다.

ModifyQa페이지에서는 페이지 진입시 axios get으로 해당 주소 param이 가지고 있는 페이지 번호로 게시물 데이터를 select해와서 useState에 set한 뒤 수정 input들에게 기본 value 값으로 주게 됩니다. 
수정 시도시 게시물 작성시와 같은 주소로 post를 하게 되는데 전송 되는 data에 게시물 번호를 포함 하고 있기 때문에 기본키를 가지고 있어 새 게시물 작성이 아닌 수정 형식으로 DB에 save가 됩니다. 이때 수정일 또한 저장됩니다.


[3]Community>QA>ReadQA 페이지

사용한 외부 라이브러리
import { Link } from 'react-router-dom';
import { useParams } from 'react-router';
import axios from "axios"

게시물 상세 페이지입니다. useParams를 사용하여 게시물 주소에서 parm 값을 추출하고 그 게시물로 이동 했을 때 axios get를 하여 서버로부터 게시물과 게시물 댓글 데이터를 select 해와서 userState에 set한 뒤 화면 상에 보여줍니다.

목록 버튼을 누르면 저장되어 있던 페이지 값을 가지고 게시판 페이지로 가게 됩니다.
로그인이 되어 있으면 댓글 달기 버튼이 보여지게 되고, 게시물 작성자와 로그인 유저가 같다면 수정과 삭제 버튼이 보여지게 됩니다. 삭제를 하게 되면 게시판 페이지로 가게 됩니다.

로그인이 되어 있지 않다면 댓글 버튼을 클릭시 로그인 안내를 하고, 마찬가지로 삭제시 로그인이 되어 있지 않거나 게시물 작성자와 로그인 유저가 같지 않다면 안내후 게시물 페이지로 이동합니다.

삭제시 Controller에 게시물 번호와 유저 아이디가 전달 되고 존재하는 유저인지, 존재하는 게시물인지, null값이 아닌지,  전달 받은 아이디와 게시물의 작성자 아이디가 일치하는지 검사후 DB에서 데이터가 삭제 됩니다. JPA 사용시 게시물 entity에서 댓글을 @OneToMany로 외래키를 설정하게 되는데 cascade = CascadeType.REMOVE 항목을 추가하여 게시물이 삭제가 되면 그에 해당하는 댓글들 또한 삭제되게 설정했습니다.

[4]Community>QA>ReadQA 페이지내 댓글 작성

로그인 되어 있을 때 댓글 달기 버튼을 누르게 되면 input 창이 생기면서 댓글을 작성, 등록, 취소할 수 있습니다. 취소 버튼을 누르면 confirm으로 의사 확인 후 작성 했던 댓글의 state 값을 공백으로 set합니다.

등록 버튼을 누르게 되면 작성 내용이 공백이라면 내용을 작성하라는 안내와 함께 인풋 창을 focus 합니다. 공백이 아니라면 로그인되어 있는지 확인 후 axios.post로 게시물 번호와 작성자, 댓글 내용을 data에 담아 서버로 전송합니다. 마찬가지로 서버에서도 전달받은 값들이 null이 아닌지 검사하고 게시물이 존재하는지 검사 후  댓글을 DB에 저장합니다. 댓글 작성이 완료 되면 랜더링을 다시하여 실시간으로 등록한 댓글을 바로 확인할 수 있습니다.


[5]Community>QA>ReadQA 페이지내 댓글 수정/삭제


댓글의 작성자와 로그인 유저가 같다면 댓글에 수정, 삭제 버튼이 보이게 됩니다.

useRef를 사용하여 수정 버튼을 누른 댓글 위치를 기억하여 해당 댓글에 수정 input창을 생성하게 됩니다.
이 input 창은 해당 댓글의 내용의 value를 가지고 있습니다. 마찬가지로 공백으로 수정 시도시 안내 후 input창을 focus를 주고, 취소 버튼을 누르면 confirm안내 후 modifiedContent useState 값을 초기화 합니다.

수정 내용을 입력하면 modifiedContent 라는 useState에 값을 저장하여  이후 이 값으로 서버에 전달합니다. 수정 시 post 주소는 댓글 작성시 주소와 같지만 게시물 번호, 작성자, 수정 내용 외에 댓글 번호까지 전송하게 되고 기본키를 가지고 있기 때문에 새로운 작성이 아닌 수정 처리로 DB에 저장됩니다. 이때 수정일 또한 저장되고 수정되는 동시에 새롭게 랜더링 하기 때문에 실시간으로 바뀐 댓글을 확인할 수 있습니다.

삭제 시에는 post 전에 로그인 되어있는지 확인 하고, Controller에서는 게시물이 존재하는지, 존재하는 유저인지, 존재하는 댓글인지 , 댓글 작성자와 삭제 신청 유저와 같은지 확인 후 Repository.delete로 삭제가 진행 됩니다.

[6]Community>QA>ReadQA 페이지내 댓글 유형

내가 작성한 댓글이라면 베이지 색으로 작성자가 표시 되지만,만일 다른 사람이 작성한 댓글이라면 회색으로 작성자가 표시됩니다. 관리자에 해당하는 "cold"라는 이름의 작성자의 글은 검정색으로 표시되게 됩니다.

 